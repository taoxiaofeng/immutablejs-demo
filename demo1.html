<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script type="text/javascript" src="./immutable.js"></script>
    <!-- <script type="text/javascript" src="./immutable.min.js"></script> -->
</head>

<body>
    <script>
        // const isBigEnough = value => value >= 10;
        // var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];


        // const oddSquares = Immutable.Seq([1, 2, 3, 4, 5, 6, 7, 8])
        // .filter(x => x % 2 == 0);
        // .map(x => x * x)
        // let a = new Range(10,30);

        // console.log(oddSquares.get(1));

        // const $set1 = Immutable.Set([1, 2, 3]);
        // const $set2 = $set1.add(1).add(10);
        // const $arr1 = Immutable.List(arr);
        // const bb = Immutable.Seq(arr).filter(x => x % 2 == 0);

        // console.log(Immutable.Seq(arr));

        /*
                        全排列主要用到的是递归和数组的插入
                        比如12的全排列，首先把1拿出来放到elementCur，再获取由1组成的数组[2],然后在循环把1插入到0,1的位置后再返回1,2][2,1]
                        如果是123那么首先获取23的全排列[2,3][3,2],然后在插入1，[1,2,3][2,1,3][2,3,1][1,3,2][3,1,2][3,2,1]
                        */
        // function permutate(array/*需要进行全排列的一维数组*/, permutatedArray/*存放返回结果*/) {
        //     if (!permutatedArray) {
        //         permutatedArray = [];
        //     }
        //     if (array.length > 1) {
        //         //弹出第一个数
        //         var elementCur = array.shift();
        //         //排列剩余的数组
        //         permutate(array, permutatedArray);
        //         //返回剩余的数组的排列长度
        //         var permutatedArrayLen = permutatedArray.length;
        //         //第一个数与其他剩余数组所有数组组合
        //         for (var j = 0; j < permutatedArrayLen; j++) {
        //             //弹出不齐的组
        //             var p = permutatedArray.shift();
        //             //把当前元素放到排列好的数组的所有位置
        //             for (var i = 0; i <= p.length; i++) {
        //                 //复制排列好的数组
        //                 var r = p.slice(0);
        //                 //插入数据到数组的位置
        //                 r.splice(i, 0, elementCur);
        //                 //保存
        //                 permutatedArray.push(r)
        //             }
        //         }
        //         //退出条件
        //     } else {
        //         permutatedArray.push([array[0]]);
        //     }
        //     return permutatedArray;
        // }
        // let A = [1,2,3,4,5,6];
        // console.log(permutate(A))

        // /*
        // 组合实现的原理非常简单，就是依次循环数组的元素，循环的嵌套层数是有m来决定的，内部的循环下标在外部的下标加1。所以用function来组装
        // */
        // function combination(arr /*n需要组合的一维数组*/ , num /*m需要取几个元素来组合*/ , fun /*对组合后的元素的处理函数，如全排列permutate*/ ) {
        //     /*这里假设num最大值为10 一般A(n,m)中的m应该不会太大 */
        //     if (arr.length < num || num > 10) {
        //         return [];
        //     }
        //     var variable = ["a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s",
        //         "t", "u"
        //     ];
        //     var replaceStr = "#$#";
        //     var str =
        //         " var arr=arguments[0]; var fun=arguments[1];  var ret=[]; for (var a = 0; a < arr.length; a++) { " +
        //         replaceStr + " } return ret;"
        //     for (var i = 1; i < num; i++) {
        //         str = str.replace(replaceStr, " for (var " + variable[i] + " =" + variable[i - 1] + "+ 1; " + variable[
        //             i] + " < arr.length; " + variable[i] + "++) { " + replaceStr + "  }")
        //     }
        //     var temp = " var temp= []; ";
        //     for (var i = 0; i < num; i++) {
        //         temp += "temp.push(arr[" + variable[i] + "]); ";
        //     }
        //     if (fun) {
        //         temp += " ret.push(fun(temp)); ";
        //     } else {
        //         temp += " ret.push(temp); ";
        //     }
        //     str = str.replace(replaceStr, temp);
        //     //console.log(str);
        //     return (new Function(str)).apply(null, [arr, fun]);
        // }

        // var a = combination([1, 2, 3, 4, 5, 6], 2, permutate);
        // for (var i = 0; i < a.length; i++) {
        //     for (var j = 0; j < a[i].length; j++) {
        //         console.log(a[i][j].join(''));
        //     }
        // }
        // function queue(arr, size) {
        //     if (size > arr.length) { return; }
        //     var allResult = [];

        //     (function (arr, size, result) {
        //         if (result.length == size) {
        //             allResult.push(result);
        //         } else {
        //             for (var i = 0, len = arr.length; i < len; i++) {
        //                 var newArr = [].concat(arr),
        //                     curItem = newArr.splice(i, 1);
        //                 arguments.callee(newArr, size, [].concat(result, curItem));
        //             }
        //         }
        //     })(arr, size, []);

        //     return allResult;
        // }
        // function showResult(result) {
        //     console.log('The number of result sets: ' + result.length);
        //     for (var i = 0, len = result.length; i < len; i++) {
        //         console.log(result[i]);
        //     }
        // }

        // // showResult(choose([1, 2, 3, 4, 5, 6], 3));
        // showResult(queue([1, 2, 3], 2));
        // function choose(arr, size) {
        //     var allResult = [];
        //     (function (arr, size, result) {
        //         var arrLen = arr.length;
        //         if (size > arrLen) {
        //             return;
        //         }
        //         if (size == arrLen) {
        //             allResult.push([].concat(result, arr))
        //         } else {
        //             for (var i = 0 ; i < arrLen; i++) {
        //                 var newResult = [].concat(result);
        //                 newResult.push(arr[i]);

        //                 if (size == 1) {
        //                     allResult.push(newResult);
        //                 } else {
        //                     var newArr = [].concat(arr);
        //                     newArr.splice(0, i + 1);
        //                     arguments.callee(newArr, size - 1, newResult);
        //                 }
        //             }
        //         }
        //     })(arr, size, []);
        //     return allResult;
        // }

        // console.log(choose(['A','B','C','D','F'], 2));
        // const isBigEnough = value => value >= 10;
        // var add = function () {

        //     var sum = 0;

        //     for (var i = 0; i < 100000000; i++) {

        //         sum += i;

        //     }

        //     return sum;

        // }

        // var b = arr.filter(value => value >= 10);
        // // 定义一个测试函数，将待测函数作为参数传入
        // function test(func) {

        //     var start = new Date().getTime(); //起始时间

        //     func(); //执行待测函数

        //     var end = new Date().getTime(); //接受时间

        //     return (end - start) + "ms"; //返回函数执行需要时间

        // }
        // // 测试并查看实际执行时间
        // var time = test(add);
        // // var time2 = test(b);
        // console.log(time);

        // var list1 = Immutable.List.of(1, 2, 3);
        // var list2 = list1.withMutations(function (list) {
        //     list.push(4).push(5).push(6).push(4).push(5).push(6).push(4).push(5).push(6).push(6).push(4).push(5)
        //         .push(6).push(4).push(5).push(6).push(4).push(5).push(6).push(6).push(4).push(5).push(6).push(4)
        //         .push(5).push(6).push(4).push(5).push(6).push(6).push(4).push(5).push(6).push(4).push(5).push(6)
        //         .push(4).push(5).push(6).push(6).push(4).push(5).push(6).push(4).push(5).push(6).push(4).push(5)
        //         .push(6).push(6).push(4).push(5).push(6).push(4).push(5).push(6).push(4).push(5).push(6).push(6)
        //         .push(4).push(5).push(6).push(4).push(5).push(6).push(4).push(5).push(6).push(6).push(4).push(5)
        //         .push(6).push(4).push(5).push(6).push(4).push(5).push(6).push(6).push(4).push(5).push(6).push(4)
        //         .push(5).push(6).push(4).push(5).push(6).push(6).push(4).push(5).push(6).push(4).push(5).push(6)
        //         .push(4).push(5).push(6).push(6);
        // });
        // console.log(list1.size);
        // console.log(list2.size);
        // var time3 = time.test(list1.withMutations);
        // console.log(list2);
        // var add2 = function () {
        //     var list = [];
        //     for (var i = 0; i < 10000; i++) {
        //         list.push(i);
        //     }
        // }

        // var time2 = test(add2);
        // console.log(time2);
        var list = [];
        for(var i = 0; i < 10000; i++) {
            list.push(i);
        }
        
        //immutable.js  Seq
        var start = new Date().getTime();
        var oddSquares = Immutable.Seq(list)
        .filter(function(x){
            console.log('immutale对象的filter执行')
            return x % 2;
        })
        .map(x => x * x); 
        oddSquares.get(20);
        var end = new Date().getTime();
        console.log((end-start) + 'ms');


        //plain object javascript 
        var start2 = new Date().getTime();
        var jsSquares = list
        .filter(function(x){
            console.log('原生数组的的filter执行')
            return x % 2;
        })
        .map(x => x * x);
        jsSquares[20];
        var end2 = new Date().getTime();
        console.log((end2-start2) + 'ms');
    </script>
</body>

</html>